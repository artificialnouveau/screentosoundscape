// Fetches JSON data and loads audio into the scene
function fetchJSONData() {
  fetch("./en_wiki_Galaxy_with_audio.json")
    .then((res) => {
      if (!res.ok) {
        throw new Error(`HTTP error! Status: ${res.status}`);
      }
      return res.json();
    })
    .then((data) => loadAudio(data)) // Loads audio elements based on JSON data
    .catch((error) => console.error("Unable to fetch data:", error));
}

// Call fetchJSONData to start the process
fetchJSONData();

// Select scene and asset elements from the DOM
const sceneEl = document.querySelector("a-scene");
const assetEl = document.querySelector("a-assets");

// Set initial layout and boundary values
const y = 1.6; // Vertical position
const d1 = 10; // Distance between title and headers
const d2 = 8; // Distance between headers and subsections
const dp = 6; // Distance between header and paragraph
let x0 = 0, z = 0, z0 = 0;
let minX = 0, maxX = 0, minZ = 0;
const margin = 2; // Boundary margin
const proxi = 2; // Proximity for collision detection

let playEnhancedAudio = false; // Flag to track whether enhanced audio playback is enabled
let playing = true; // Flag to track play/pause state
let sounds = []; // Array to store sound elements

document.addEventListener("keyup", (event) => {
  if (event.code === "Space") {
    checkAudio(sounds); // Toggle play/pause on space key press
  }

  if (event.code === "Tab") {
    playEnhancedAudio = !playEnhancedAudio; // Toggle enhanced audio playback mode
    console.log(`Enhanced audio mode: ${playEnhancedAudio ? "ON" : "OFF"}`);
  }
});

//////////////// LOAD AUDIO ///////////////////
// Processes the data and generates audio elements
function loadAudio(data) {
  // Load title audio
  createAudio(data["H1 Galaxy"].audio_path.replace("mp3s\\", "").replace(".mp3", ""));
  
  // Load introduction audio
  createAudio(data.P.audio_path.replace("mp3s\\", "").replace(".mp3", ""));

  // Recursively process section audio
  iterateAudio(data.Sections, "Sections_");

  // Create the layout for visual elements
  drawLayout(data);
}

// Recursively iterates through sections and subsections to load audio
function iterateAudio(section, prename) {
  for (const key in section) {
    const name = prename + key.replace(":", "").replaceAll(" ", "_");
    createAudio(section[key].audio_path.replace("mp3s\\", "").replace(".mp3", ""));

    if (section[key].P && section[key].P.audio_path !== "") {
      createAudio(section[key].P.audio_path.replace("mp3s\\", "").replace(".mp3", ""));
    }

    // Recursively process subsections if they exist
    if (section[key].Subsections) {
      iterateAudio(section[key].Subsections, name + "_Subsections_");
    }
  }
}

// Creates an audio element and appends it to the asset element
function createAudio(name) {
  const audioEl = document.createElement("audio");
  let url = `https://cdn.glitch.global/53d6d00c-ae48-4ff9-bb80-4a61d4cfaa29/${name}.mp3`;

  // Enhanced audio mode: check for title_opening and title_closing audio
  if (name.includes("Title_header1")) {
    const openingEl = document.createElement("audio");
    openingEl.setAttribute("id", "title_opening");
    openingEl.setAttribute("preload", "auto");
    openingEl.setAttribute("src", `https://cdn.glitch.global/53d6d00c-ae48-4ff9-bb80-4a61d4cfaa29/title_opening.mp3`);
    assetEl.appendChild(openingEl);

    const closingEl = document.createElement("audio");
    closingEl.setAttribute("id", "title_closing");
    closingEl.setAttribute("preload", "auto");
    closingEl.setAttribute("src", `https://cdn.glitch.global/53d6d00c-ae48-4ff9-bb80-4a61d4cfaa29/title_closing.mp3`);
    assetEl.appendChild(closingEl);
  }

  audioEl.setAttribute("id", name);
  audioEl.setAttribute("preload", "auto");
  audioEl.setAttribute("src", url);

  assetEl.appendChild(audioEl); // Append audio element to asset element
}

// Enhanced audio playback logic
function playEnhanced(sphereEl, soundName) {
  const isHeader = soundName.includes("_header");
  const isParagraph = soundName.includes("_paragraph");
  const headerNumberMatch = soundName.match(/header(\d+)/); // Extract header number if exists

  // Logic to play enhanced audio (opening, main, closing)
  if (playEnhancedAudio) {
    if (soundName === "Title_header1") {
      // Handle title specific case
      playAudioSequence(sphereEl, [
        "title_opening",
        soundName,
        "title_closing"
      ]);
    } else if (isHeader && headerNumberMatch) {
      const headerNumber = headerNumberMatch[1];
      playAudioSequence(sphereEl, [
        `header_${headerNumber}_opening`,
        soundName,
        `header_${headerNumber}_closing`
      ]);
    } else if (isParagraph) {
      playAudioSequence(sphereEl, [
        `paragraph_opening`,
        soundName,
        `paragraph_closing`
      ]);
    } else {
      sphereEl.components.sound.playSound(); // Play the main sound if no enhancement is found
    }
  } else {
    sphereEl.components.sound.playSound(); // Regular playback without enhancements
  }
}

// Function to play a sequence of audio files one after the other
function playAudioSequence(sphereEl, audioIds) {
  let currentIndex = 0;

  const playNextAudio = () => {
    if (currentIndex < audioIds.length) {
      const audioId = audioIds[currentIndex];
      const audioEl = document.querySelector(`#${audioId}`);

      if (audioEl) {
        sphereEl.components.sound.stopSound(); // Stop the current sound if it's playing
        sphereEl.components.sound.playSound(); // Play the new audio

        // Play the next audio after the current one finishes
        audioEl.onended = () => {
          currentIndex++;
          playNextAudio();
        };
      } else {
        // If audio file does not exist, play the next one in sequence
        currentIndex++;
        playNextAudio();
      }
    }
  };

  playNextAudio(); // Start playing the first audio in sequence
}

//////////////// DRAW LAYOUT ///////////////////
// Handles the creation of visual and interactive elements in the scene
function drawLayout(data) {
  // Create title element (pink)
  z = -d1;
  const titleEl = createElement(sceneEl, x0, y, z, "#EF2D5E", "title", "title", data["H1 Galaxy"].audio_path.replace("mp3s\\", "").replace(".mp3", ""), true, true);

  // Create introduction element (pink)
  const introEl = createElement(titleEl, x0, 0, z, "#EF2D5E", "intro", "intro", data.P.audio_path.replace("mp3s\\", "").replace(".mp3", ""), true, true);

  // Recursively create sections and subsections
  iterateSection(x0, 0, z, d1, data.Sections, introEl, "Sections_", 0);

  // Add sound collision detection and boundary
  sounds = document.querySelectorAll("a-sphere");
  document.querySelector("[camera]").setAttribute("check-collide", "");

  // Create boundary sound object (ivory color)
  createElement(sceneEl, minX - margin, y, z0 + margin, "#F0FFFF", "sound-cues", "bound", "bound-cue", false, false);
}

// Recursively iterates through sections, creating header and paragraph elements
function iterateSection(x, y, z, d, section, parentEl, prename, angle) {
  const numSections = Object.keys(section).length;
  const degStep = numSections === 1 ? Math.PI / 2 : Math.PI / (numSections - 1);

  Object.keys(section).forEach((key, i) => {
    const name = prename + key.replace(":", "").replaceAll(" ", "_");
    const headerName = section[key].audio_path.replace("mp3s\\", "").replace(".mp3", "");

    // Calculate position for the section
    const x1 = -d * Math.cos(degStep * i + angle);
    const z1 = -d / 2 - d * Math.sin(degStep * i + angle);

    // Create header element (blue)
    const headerEl = createElement(parentEl, x1, y, z1, "#00FFFF", "header", `${key}${i}`, headerName, true, true);

    // If paragraph exists, create it (yellow)
    if (section[key].P) {
      const xp = -dp * Math.cos(degStep * i + angle);
      const zp = -dp * Math.sin(degStep * i + angle);
      createElement(headerEl, xp, y, zp, "#FFFF00", "p", `${key}${i}_p`, section[key].P.audio_path.replace("mp3s\\", "").replace(".mp3", ""), true, true);
    }

    // Recursively handle subsections
    if (section[key].Subsections) {
      iterateSection(x1, y, z1, d2, section[key].Subsections, headerEl, name + "_Subsections_", 0);
    }
  });
}

// Helper function to create a visual element (sphere) in the scene
function createElement(parentEl, x, y, z, color, className, id, soundId, collide, autoPlay) {
  const sphereEl = document.createElement("a-sphere");

  // Set attributes for the sphere element
  sphereEl.setAttribute("color", color);
  sphereEl.setAttribute("shader", "flat");
  sphereEl.setAttribute("radius", "0.5");
  sphereEl.setAttribute("position", `${x} ${y} ${z}`);
  sphereEl.setAttribute("class", className);
  sphereEl.setAttribute("id", id);

  // Set sound attributes
  const soundSrc = `src:#${soundId}; rolloffFactor: 3`;
  sphereEl.setAttribute("sound", autoPlay ? `${soundSrc}; autoplay: true; loop: false; distanceModel: exponential; refDistance: 3` : soundSrc);

  // Enable collision detection if required
  if (collide) {
    sphereEl.setAttribute("collide", "");
  }

  // Append the created element to its parent
  parentEl.appendChild(sphereEl);

  return document.getElementById(id); // Return the created element
}

//////////////// PLAY AUDIO //////////////////
// Function to play or pause audio for all elements
function checkAudio(audioArray) {
  if (!playing) {
    audioArray.forEach((s) => s.components.sound.playSound());
    playing = true;
    console.log("play");
  } else {
    audioArray.forEach((s) => s.components.sound.pauseSound());
    playing = false;
    console.log("stop");
  }
}

// Function to handle the proximity-based collision detection and audio playback
AFRAME.registerComponent("collide", {
  tick() {
    const cameraEl = document.querySelector("[camera]");
    const camX = cameraEl.object3D.position.x;
    const camZ = cameraEl.object3D.position.z;

    this.el.getObject3D("mesh").getWorldPosition(this.worldpos);

    if (distance(camX, camZ, this.worldpos.x, this.worldpos.z) < proxi) {
      // Enhanced audio playback handling
      if (playEnhancedAudio) {
        playEnhanced(this.el, this.el.id); // Play enhanced audio with opening/closing
      } else {
        sounds.forEach((s) => {
          if (s !== this.el) {
            s.components.sound.pauseSound();
          }
        });
        this.el.components.sound.playSound(); // Play regular audio
      }
    }
  }
});

// Helper function to calculate distance between two points (x1, z1) and (x2, z2)
function distance(x1, z1, x2, z2) {
  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(z1 - z2, 2));
}
