// Fetches JSON data and loads audio into the scene
function fetchJSONData() {
  fetch("./en_wiki_Galaxy_with_audio.json")
    .then((res) => {
      if (!res.ok) {
        throw new Error(`HTTP error! Status: ${res.status}`);
      }
      return res.json();
    })
    .then((data) => loadAudio(data)) // Loads audio elements based on JSON data
    .catch((error) => console.error("Unable to fetch data:", error));
}

// Call fetchJSONData to start the process
fetchJSONData();

// Select scene and asset elements from the DOM
const sceneEl = document.querySelector("a-scene");
const assetEl = document.querySelector("a-assets");

// Set initial layout and boundary values
const y = 1.6; // Vertical position
const d1 = 10; // Distance between title and headers
const d2 = 8; // Distance between headers and subsections
const dp = 6; // Distance between header and paragraph
let x0 = 0, z = 0, z0 = 0;
let minX = 0, maxX = 0, minZ = 0;
const margin = 2; // Boundary margin
const proxi = 2; // Proximity for collision detection

//////////////// LOAD AUDIO ///////////////////
// Processes the data and generates audio elements
function loadAudio(data) {
  // Load title audio
  createAudio(data["H1 Galaxy"].audio_path.replace("mp3s\\", "").replace(".mp3", ""));
  
  // Load introduction audio
  createAudio(data.P.audio_path.replace("mp3s\\", "").replace(".mp3", ""));

  // Recursively process section audio
  iterateAudio(data.Sections, "Sections_");

  // Create the layout for visual elements
  drawLayout(data);
}

// Recursively iterates through sections and subsections to load audio
function iterateAudio(section, prename) {
  for (const key in section) {
    const name = prename + key.replace(":", "").replaceAll(" ", "_");
    createAudio(section[key].audio_path.replace("mp3s\\", "").replace(".mp3", ""));

    if (section[key].P && section[key].P.audio_path !== "") {
      createAudio(section[key].P.audio_path.replace("mp3s\\", "").replace(".mp3", ""));
    }

    // Recursively process subsections if they exist
    if (section[key].Subsections) {
      iterateAudio(section[key].Subsections, name + "_Subsections_");
    }
  }
}

// Creates an audio element and appends it to the asset element
function createAudio(name) {
  const audioEl = document.createElement("audio");
  let url = `https://cdn.glitch.global/53d6d00c-ae48-4ff9-bb80-4a61d4cfaa29/${name}.mp3`;

  // Enhanced audio mode: check for title_opening and title_closing audio
  if (name.includes("Title_header1")) {
    const openingEl = document.createElement("audio");
    openingEl.setAttribute("id", "title_opening");
    openingEl.setAttribute("preload", "auto");
    openingEl.setAttribute("src", `https://cdn.glitch.global/53d6d00c-ae48-4ff9-bb80-4a61d4cfaa29/title_opening.mp3`);
    assetEl.appendChild(openingEl);

    const closingEl = document.createElement("audio");
    closingEl.setAttribute("id", "title_closing");
    closingEl.setAttribute("preload", "auto");
    closingEl.setAttribute("src", `https://cdn.glitch.global/53d6d00c-ae48-4ff9-bb80-4a61d4cfaa29/title_closing.mp3`);
    assetEl.appendChild(closingEl);
  }

  audioEl.setAttribute("id", name);
  audioEl.setAttribute("preload", "auto");
  audioEl.setAttribute("src", url);

  assetEl.appendChild(audioEl); // Append audio element to asset element
}

//////////////// DRAW LAYOUT ///////////////////
// Handles the creation of visual and interactive elements in the scene
function drawLayout(data) {
  // Create title element (pink)
  z = -d1;
  const titleEl = createElement(sceneEl, x0, y, z, "#EF2D5E", "title", "title", data["H1 Galaxy"].audio_path.replace("mp3s\\", "").replace(".mp3", ""), true, true);

  // Create introduction element (pink)
  const introEl = createElement(titleEl, x0, 0, z, "#EF2D5E", "intro", "intro", data.P.audio_path.replace("mp3s\\", "").replace(".mp3", ""), true, true);

  // Recursively create sections and subsections
  iterateSection(x0, 0, z, d1, data.Sections, introEl, "Sections_", 0);

  // Add sound collision detection and boundary
  sounds = document.querySelectorAll("a-sphere");
  document.querySelector("[camera]").setAttribute("check-collide", "");

  // Create boundary sound object (ivory color)
  createElement(sceneEl, minX - margin, y, z0 + margin, "#F0FFFF", "sound-cues", "bound", "bound-cue", false, false);
}

// Recursively iterates through sections, creating header and paragraph elements
function iterateSection(x, y, z, d, section, parentEl, prename, angle) {
  const numSections = Object.keys(section).length;
  const degStep = numSections === 1 ? Math.PI / 2 : Math.PI / (numSections - 1);

  Object.keys(section).forEach((key, i) => {
    const name = prename + key.replace(":", "").replaceAll(" ", "_");
    const headerName = section[key].audio_path.replace("mp3s\\", "").replace(".mp3", "");

    // Calculate position for the section
    const x1 = -d * Math.cos(degStep * i + angle);
    const z1 = -d / 2 - d * Math.sin(degStep * i + angle);

    // Create header element (blue)
    const headerEl = createElement(parentEl, x1, y, z1, "#00FFFF", "header", `${key}${i}`, headerName, true, true);

    // If paragraph exists, create it (yellow)
    if (section[key].P) {
      const xp = -dp * Math.cos(degStep * i + angle);
      const zp = -dp * Math.sin(degStep * i + angle);
      createElement(headerEl, xp, y, zp, "#FFFF00", "p", `${key}${i}_p`, section[key].P.audio_path.replace("mp3s\\", "").replace(".mp3", ""), true, true);
    }

    // Recursively handle subsections
    if (section[key].Subsections) {
      iterateSection(x1, y, z1, d2, section[key].Subsections, headerEl, name + "_Subsections_", 0);
    }
  });
}

// Helper function to create a visual element (sphere) in the scene
function createElement(parentEl, x, y, z, color, className, id, soundId, collide, autoPlay) {
  const sphereEl = document.createElement("a-sphere");
  
  // Set attributes for the sphere element
  sphereEl.setAttribute("color", color);
  sphereEl.setAttribute("shader", "flat");
  sphereEl.setAttribute("radius", "0.5");
  sphereEl.setAttribute("position", `${x} ${y} ${z}`);
  sphereEl.setAttribute("class", className);
  sphereEl.setAttribute("id", id);
  
  // Set sound attributes
  const soundSrc = `src:#${soundId}; rolloffFactor: 3`;
  sphereEl.setAttribute("sound", autoPlay ? `${soundSrc}; autoplay: true; loop: false; distanceModel: exponential; refDistance: 3` : soundSrc);
  
  // Enable collision detection if required
  if (collide) {
    sphereEl.setAttribute("collide", "");
  }
  
  // Append the created element to its parent
  parentEl.appendChild(sphereEl);
  
  return document.getElementById(id); // Return the created element
}

//////////////// PLAY AUDIO //////////////////
// Toggles the play/pause state of audio elements when the spacebar is pressed
document.addEventListener("keyup", (event) => {
    if (event.code === "Space") {
      checkAudio(sounds);
    }
  });
  
  // Function to play or pause audio for all elements
  function checkAudio(audioArray) {
    if (playing) {
      audioArray.forEach((s) => s.components.sound.pauseSound());
      playing = false;
    } else {
      audioArray.forEach((s) => s.components.sound.playSound());
      playing = true;
    }
  }
  
  // Helper function to calculate distance between two points (x1, z1) and (x2, z2)
  function distance(x1, z1, x2, z2) {
    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(z1 - z2, 2));
  }
  
  //////////////// GET WORLD POSITION //////////////////
  // Component to retrieve and track the world position of an element
  AFRAME.registerComponent("world-pos", {
    init() {
      this.worldpos = new THREE.Vector3();
    },
    update() {
      this.el.getObject3D("mesh").getWorldPosition(this.worldpos);
      
      // Update min/max values for boundary checking
      if (this.worldpos.x < 0 && this.worldpos.x < minX) minX = this.worldpos.x;
      if (this.worldpos.x > 0 && this.worldpos.x > maxX) maxX = this.worldpos.x;
      if (this.worldpos.z < minZ) minZ = this.worldpos.z;
    },
  });
  
  //////////////// HIT BOUNDS //////////////////
  // Component to detect and handle boundary collisions
  AFRAME.registerComponent("hit-bounds", {
    tick() {
      const bound = document.querySelector("#bound");
      const elX = this.el.object3D.position.x;
      const elZ = this.el.object3D.position.z;
      
      // Check and handle boundary collisions along the z-axis
      if (this.el.object3D.position.z >= z0 + margin) {
        this.el.object3D.position.z = z0 + margin;
        bound.object3D.position.set(elX, y, z0 + margin + 0.5);
        if (!hit) triggerHit(bound);
      }
      if (this.el.object3D.position.z <= minZ - margin) {
        this.el.object3D.position.z = minZ - margin;
        bound.object3D.position.set(elX, y, minZ - margin - 0.5);
        if (!hit) triggerHit(bound);
      }
      // Check and handle boundary collisions along the x-axis
      if (this.el.object3D.position.x >= maxX + margin) {
        this.el.object3D.position.x = maxX + margin;
        bound.object3D.position.set(maxX + margin + 0.5, y, elZ);
        if (!hit) triggerHit(bound);
      }
      if (this.el.object3D.position.x <= minX - margin) {
        this.el.object3D.position.x = minX - margin;
        bound.object3D.position.set(minX - margin - 0.5, y, elZ);
        if (!hit) triggerHit(bound);
      }
      
      // Reset hit state if no boundaries are being crossed
      if (elX > minX - margin && elX < maxX + margin && elZ > minZ - margin && elZ < z0 + margin) {
        if (hit) {
          bound.components.sound.stopSound();
          hit = false;
        }
      }
    },
  });
  
  // Helper function to trigger boundary hit sound
  function triggerHit(bound) {
    hit = true;
    bound.components.sound.playSound();
  }
  
  // Registers component to detect and handle collisions between camera and objects
  AFRAME.registerComponent("collide", {
    tick() {
      const cameraEl = document.querySelector("[camera]");
      const camX = cameraEl.object3D.position.x;
      const camZ = cameraEl.object3D.position.z;
  
      this.el.getObject3D("mesh").getWorldPosition(this.worldpos);
  
      if (distance(camX, camZ, this.worldpos.x, this.worldpos.z) < proxi) {
        sounds.forEach((s) => s.components.sound.pauseSound());
      }
    },
  });
  
  // Registers a component to snap camera to object when in close proximity
  AFRAME.registerComponent("check-collide", {
    init() {
      this.snapped = false;
    },
    tick() {
      let worldpos = new THREE.Vector3();
      const cameraPos = this.el.object3D.position;
  
      sounds.forEach((s) => {
        s.getObject3D("mesh").getWorldPosition(worldpos);
  
        if (distance(cameraPos.x, cameraPos.z, worldpos.x, worldpos.z) < proxi) {
          if (!this.snapped) {
            this.el.object3D.position.set(worldpos.x, y, worldpos.z);
            setTimeout(() => this.snapped = true, 1000);
          }
        }
      });
    },
  });